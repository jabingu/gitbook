
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>ICCD 2018 · jabingu's Book</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="jabingu">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search-pro/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-donate/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="3-ICCD-2017.html" />
    
    
    <link rel="prev" href="1-ICCD-2019.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    
    
        
        <li>
            <a href="https://jabingu.com" target="_blank" class="custom-link">Blog</a>
        </li>
    
    

    
    <li class="divider"></li>
    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">作品</li>
        
        
    
        <li class="chapter " data-level="2.1" >
            
                <span>
            
                    
                    [其他]
            
                </span>
            

            
        </li>
    

    
        
        <li class="header">conference</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="1-ICCD-2019.html">
            
                <a href="1-ICCD-2019.html">
            
                    
                    ICCD 2019
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="3.2" data-path="2-ICCD-2018.html">
            
                <a href="2-ICCD-2018.html">
            
                    
                    ICCD 2018
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="3-ICCD-2017.html">
            
                <a href="3-ICCD-2017.html">
            
                    
                    ICCD 2017
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.4" data-path="4-IPDPS-2017.html">
            
                <a href="4-IPDPS-2017.html">
            
                    
                    IPDPS 2017
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.5" data-path="5-EuroSys-2019.html">
            
                <a href="5-EuroSys-2019.html">
            
                    
                    EuroSys 2019
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            本书使用 GitBook 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >ICCD 2018</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon "></span><a href="#iccd-2018"><b></b>ICCD 2018</a></li><ul><li><span class="title-icon "></span><a href="#1-best-papers-session"><b></b>1: Best Papers Session</a></li><li><span class="title-icon "></span><a href="#2a-ssd"><b></b>2A: SSD</a></li><li><span class="title-icon "></span><a href="#2b-side-channels"><b></b>2B: Side Channels</a></li><li><span class="title-icon "></span><a href="#3a-security-and-capability"><b></b>3A: Security and Capability</a></li><li><span class="title-icon "></span><a href="#3b-microarchitecture"><b></b>3B: Microarchitecture</a></li><li><span class="title-icon "></span><a href="#4a-logic-and-circuit-design-1"><b></b>4A: Logic and Circuit Design 1</a></li><li><span class="title-icon "></span><a href="#4b-design-automation"><b></b>4B: Design Automation</a></li><li><span class="title-icon "></span><a href="#5a-novel-architectures"><b></b>5A: Novel Architectures</a></li><li><span class="title-icon "></span><a href="#5b-memory-1"><b></b>5B: Memory 1</a></li><li><span class="title-icon "></span><a href="#6a-memory-2"><b></b>6A: Memory 2</a></li><li><span class="title-icon "></span><a href="#6b-logic-and-circuit-design-2"><b></b>6B: Logic and Circuit Design 2</a></li><li><span class="title-icon "></span><a href="#7a-accelerators-and-gpus"><b></b>7A: Accelerators and GPUs</a></li><li><span class="title-icon "></span><a href="#7b-potpouri-1"><b></b>7B: Potpouri 1</a></li><li><span class="title-icon "></span><a href="#8a-nvm"><b></b>8A: NVM</a></li><li><span class="title-icon "></span><a href="#8b-test-and-verification"><b></b>8B: Test and Verification</a></li><li><span class="title-icon "></span><a href="#9a-network-on-chip-and-synchronization"><b></b>9A: Network on Chip and Synchronization</a></li><li><span class="title-icon "></span><a href="#9b-potpouri-2"><b></b>9B: Potpouri 2</a></li><li><span class="title-icon "></span><a href="#10a-file-system-and-cloud"><b></b>10A: File System and Cloud</a></li><li><span class="title-icon "></span><a href="#10b-fpga-and-machine-learning"><b></b>10B: FPGA and Machine Learning</a></li></ul></ul></div><a href="#iccd-2018" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><h1 id="iccd-2018"><a name="iccd-2018" class="anchor-navigation-ex-anchor" href="#iccd-2018"><i class="fa fa-link" aria-hidden="true"></i></a><a name="iccd-2018" class="plugin-anchor" href="#iccd-2018"><i class="fa fa-link" aria-hidden="true"></i></a>ICCD 2018</h1>
<blockquote>
<p>&#x6B7B;&#x4EA1;&#x662F;&#x6D3B;&#x8FC7;&#x7684;&#x751F;&#x547D;&#xFF0C;&#x751F;&#x6D3B;&#x662F;&#x5728;&#x8DEF;&#x4E0A;&#x7684;&#x6B7B;&#x4EA1;&#x3002;</p>
<p align="right">&#x2014;&#x2014;&#x535A;&#x5C14;&#x8D6B;&#x65AF;&#x3000;&#x3000;</p>



</blockquote>
<p><strong>&#x76EE;&#x5F55;&#xFF1A;</strong></p>
<blockquote>
<p>Session 1: Best Papers Session<br>Session 2A: SSD<br>Session 2B: Side Channels<br>Session 3A: Security and Capability<br>Session 3B: Microarchitecture<br>Session 4A: Logic and Circuit Design 1<br>Session 4B: Design Automation<br>Session 5A: Novel Architectures<br>Session 5B: Memory 1<br>Session 6A: Memory 2<br>Session 6B: Logic and Circuit Design 2<br>Session 7A: Accelerators and GPUs<br>Session 7B: Potpouri 1<br>Session 8A: NVM<br>Session 8B: Test and Verification<br>Session 9A: Network on Chip and Synchronization<br>Session 9B: Potpouri 2<br>Session 10A: File System and Cloud<br>Session 10B: FPGA and Machine Learning  </p>
</blockquote>
<h2 id="1-best-papers-session"><a name="1-best-papers-session" class="anchor-navigation-ex-anchor" href="#1-best-papers-session"><i class="fa fa-link" aria-hidden="true"></i></a><a name="1-best-papers-session" class="plugin-anchor" href="#1-best-papers-session"><i class="fa fa-link" aria-hidden="true"></i></a><strong>1: Best Papers Session</strong></h2>
<p><strong>Composable Template Attacks Using Templates for Individual Architectural Components</strong></p>
<blockquote>
<p>&#x200B;    Bozhi Liu, Roman Lysecky, Janet Meiling Wang Roveda</p>
</blockquote>
<p>With embedded systems and IoT devices being widely deployed nowadays, their <strong>security</strong> becomes a major concern. Among all possible attacks, <strong>side channel attacks (SCA)</strong> represent a major source of threats. For power side channels, template attacks have been proven to be efficient and widely applicable. Traditional template attacks require physical access to an identical target device for extensive profiling to construct the attack template. In this paper, we present a composable template attack that relaxes this requirement by constructing the attack template as a composition of templates from individual architectural components, including processor, caches, and memories. The proposed approach enables an attacker to construct a template using only information of a system&apos;s components and device models thereof.</p>
<hr>
<p><strong>Thermal-Aware 3D Symmetrical Buffered Clock Tree Synthesis</strong></p>
<blockquote>
<p>&#x200B;    Deok Keun Oh, Mu Jun Choi, Juho Kim</p>
</blockquote>
<p>The semiconductor industry has accepted <strong>three dimensional integrated circuits (3D ICs)</strong> as a possible solution to address speed and power management problems. In addition, 3D ICs have recently demonstrated a huge potential in reducing wire length and increasing the density of a chip. However, the growing density in chips such as TSV-based 3D ICs has brought increased temperature on chip and temperature gradients depending on location. Thus, through silicon via (TSV)-based 3D clock tree synthesis (CTS) causes <strong>thermal problem</strong> leading to large clock skew. We propose a novel 3D symmetrical buffered clock tree synthesis considering thermal variation. First, 3D abstract tree topology based on nearest neighbor selection with median cost (3D-NNM) is constructed by pairing sinks that have similar power consumption. Second, the layer assignment of internal nodes is determined for uniform TSV distribution. Third, in thermal-aware 3D deferred merging embedding (DME), the exact location of TSV is determined and wire routing/buffer insertion are performed after thermal profiles based on grid are obtained. The proposed method is verified using a 45nm process technology and utilized a predictive technology model (PTM) with HSPICE. Also, our CTS is evaluated for IBM and ISPD&apos;09 benchmarks with no blockages. In experimental results, we can achieve average 18% of clock skew reduction compared to existing thermal-aware 3D CTS. Therefore, thermal-aware 3D symmetrical buffered clock tree synthesis presented in this work is very efficient for circuit reliability.</p>
<hr>
<p><strong>Low-Overhead Microarchitectural Patching for Multicore Memory Subsystems</strong></p>
<blockquote>
<p>&#x200B;    Doowon Lee, Opeoluwa Matthews, Valeria Bertacco</p>
</blockquote>
<p>In this work, we present <strong>&#x3BC;MemPatch</strong>, a comprehensive, efficient patching solution to overcome escaped design flaws in multicore memory subsystems at runtime. Unlike conventional microcode patching, &#x3BC;MemPatch strives to accurately pinpoint bug-prone microarchitectural states at runtime, by using a small programmable-logic fabric. &#x3BC;MemPatch comprises two main components: <strong>a bug-anticipation module</strong> and <strong>a bug-elusion module</strong>. The bug-anticipation module tracks, at runtime, the progress of microarchitectural events related to memory operations. Specifically, we model event sequences as finite state machines (FSM), where some of the FSM states represent bug-prone microarchitectural states. Upon detection of a bug-prone state, the bug-elusion module limits reorderings of instructions or memory accesses, so as to avoid falling into the bug state. We propose a few different bug-elusion methods, including squashing instructions, delaying cache evictions, and dynamically inserting fence operations. We implemented &#x3BC;MemPatch in a cycle-accurate full-system <strong>simulator</strong>. We then embedded eleven design bugs that span a wide range of bug types, which had been disclosed in product errata documents. Our evaluation with an in-house micro-benchmark suite and the SPLASH-2 suite shows that &#x3BC;MemPatch&apos;s bug-elusion methods successfully bypass all bugs at a performance impact of less than 1% on average (SPLASH-2). The area overhead in our setup is approximately 6% for an ARM Cortex-A9 core on average, over all bugs we considered.</p>
<hr>
<p><strong>Power Grab in Aggressively Provisioned Data Centers: What is the Risk and What Can Be Done About It</strong></p>
<blockquote>
<p>&#x200B;    Xiaofeng Hou, Luoyao Hao, Chao Li, Quan Chen, Wenli Zheng, Minyi Guo</p>
</blockquote>
<p>Aggressively provisioned <strong>data centers</strong> achieve great cost savings by over-committing the very expensive <strong>power</strong> distribution infrastructure. However, <u>existing proposals</u> for managing load power demand in such a data center are largely <u>utilization-driven</u>, overlooking power-related interferences among users. An important observation is that some tasks can impact existing power budget management framework and disrupt normal operation by taking away the precious public power capacity. This vulnerability exposes data centers to a new type of risk that we call power grab, which is essentially hostile power resource competition. It could worsen the performance-utilization tradeoff in a power-constrained computing environment. Anticipating a growing case for power-oriented competition, we propose <strong>CFP</strong>, a resilient power capacity management frame-work for improving the <u>fairness</u> and service <u>quality</u> in scale-out data centers. Our solution features a market-based power re-source allocation and billing scheme that involves users in the loop. It allows the data center to bypass the formidable task of identifying malicious users and defend against power grab with reward and punishment incentives. We build a proof-of-concept system and also evaluate our design with realistic Google cluster traces. Compared to prior arts, CFP can increase the average performance-cost ratio by 1.8X. It can boost the total throughput in an APDC by 15% under severe power contention. Our design allows scale-out data centers to safely exploit the benefits that power over-subscription may provide, with minor overhead.</p>
<p><strong>&#x6570;&#x636E;&#x4E2D;&#x5FC3;</strong>&#xFF1B;<strong>&#x80FD;&#x8017;&#x8C03;&#x5EA6;</strong></p>
<h2 id="2a-ssd"><a name="2a-ssd" class="anchor-navigation-ex-anchor" href="#2a-ssd"><i class="fa fa-link" aria-hidden="true"></i></a><a name="2a-ssd" class="plugin-anchor" href="#2a-ssd"><i class="fa fa-link" aria-hidden="true"></i></a>2A: SSD</h2>
<p><strong>Pensieve: a Machine Learning Assisted SSD Layer for Extending the Lifetime</strong></p>
<blockquote>
<p>&#x200B;    Te I, Murtuza Lokhandwala, Yu-Ching Hu, Hung-Wei Tseng</p>
</blockquote>
<p>As the capacity per unit cost dropping, flash-based SSDs become popular in various computing scenarios. However, the restricted program-erase cycles still severely limit cost-effectiveness of flash-based storage solutions. This paper proposes <strong>Pensieve</strong>, a <strong>machine-learning</strong> assisted SSD firmware layer that transparently helps <u>reduce the demand for programs and erases</u>. Pensieve efficiently <u>classifies writing data into different compression categories without hints from software systems</u>. Data with the same category may use a shared dictionary to <strong>compress</strong> the content, allowing Pensieve to further avoid duplications. As Pensieve does not require any modification in the software stack, Pensieve is compatible with existing applications, file systems and operating systems. With modern SSD architectures, implementing a Pensieve-compliant SSD also requires no additional hardware, providing a drop-in upgrade for existing storage systems. The experimental result on our prototype Pensieve SSD shows that Pensieve can reduce the amount of program operations by 19%, while delivering competitive performance.</p>
<p><strong>&#x673A;&#x5668;&#x5B66;&#x4E60;</strong>&#xFF1B;<strong>ssd</strong>&#xFF1B;<strong>&#x6570;&#x636E;&#x538B;&#x7F29;</strong></p>
<hr>
<p><strong>Selective Compression Scheme for Read Performance Improvement on Flash Devices</strong></p>
<blockquote>
<p>&#x200B;    Qiao Li, Liang Shi, Riwei Pan, Cheng Ji, Xiaoqiang Li, Chun Jason Xue</p>
</blockquote>
<p>The increasing density and capacity of NAND flash memory leads to degraded reliability. To address the <strong>reliability</strong> issue, <strong>low-density parity-check code (LDPC)</strong> has been deployed in NAND flash memories due to its strong error correction capability. The drawback of LDPC is that, to correct data with high raw bit error rate (RBER), read latency will be amplified. To improve read performance, this paper proposes to apply <u>lossless compression to reduce RBER on data pages</u>. However, compression and decompression incur time overheads. Compressing all the data pages for RBER reduction will degrade write performance. In addition, the variation of compression ratio leads to variation of RBER reduction, thus varied read latency reduction. In this work, a selective data compression scheme is proposed for read performance improvement. Both read frequency and compression ratio of data are taken into consideration. Data in a flash page with high read frequency and good compressibility are prioritized for compression. Experimental results show that the proposed scheme can improve read performance by 42% on average, without impacting write performance.</p>
<p><strong>&#x6570;&#x636E;&#x538B;&#x7F29;</strong>&#xFF1B;<strong>LDPC</strong></p>
<hr>
<p><strong>OSPADA: One-Shot Programming Aware Data Allocation Policy to Improve 3D NAND Flash Read Performance</strong></p>
<blockquote>
<p><strong>Fei Wu</strong>, Zuo Lu, You Zhou, Xubin He, Zhi-hu Tan, <strong>Changsheng Xie</strong>:</p>
</blockquote>
<p>Charge trap (CT) based <strong>3D NAND flash</strong> is predominating the flash storage market due to higher density, better performance and endurance than planar flash. CT-based 3D flash programs multiple pages in a word line at a time, called <u>one-shot programming</u>, unlike planar flash which programs one page at a time. Solid state drives (SSDs) utilize the internal parallelism to improve the performance, but one-shot programming is likely to program logically sequential data into one parallel unit (i.e., a plane) and thus degrades the read parallelism. In this paper, we propose a <u><em>one-shot programming aware data allocation policy</em></u>, called <strong>OSPADA</strong>, to improve the read performance of CT flash based SSDs by enhancing read parallelism. OSPADA reorders written data to distribute logically sequential data into different parallel units using the distance aware round-robin strategy. Experimental results show that OSPADA improves the read performance by up to 22.8% compared with traditional dynamic data allocation policies.</p>
<p>&#x7531;&#x4E8E;&#x8BFB;&#x5199;&#x5355;&#x5143;&#x548C;&#x64E6;&#x9664;&#x7684;&#x5355;&#x5143;&#x7684;&#x5927;&#x5C0F;&#x95EE;&#x9898;</p>
<hr>
<p><strong>Cap: Exploiting Data Correlations to Improve the Performance and Endurance of SSD RAID</strong></p>
<blockquote>
<p>&#x200B;    Gaoxiang Xu, Zhipeng Tan, Dan Feng, Yifeng Zhu, Xinyan Zhang, Jie Xu</p>
</blockquote>
<p><strong>Parity-based RAID</strong> provides system-level fault tolerance. However, parity updates caused by small writes introduce lots of extra I/Os, degrading I/O performance and wearing SSDs out. It has been proposed to use <strong>Non-Volatile Memory (NVM) as a parity cache</strong> on an SSD <strong>RAID</strong> to postpone parity updates until the whole stripe has been updated. However, this often fails because of skewed distribution of <u>hot data chunks within a stripe.</u> In real workloads, it is often difficult to achieve a full-stripe update even after a long delay. In this paper, we propose a <u><em>Correlation aware parity caching scheme</em></u>, called <strong>Cap</strong>, for SSD-based RAIDs. The key idea behind Cap is to periodically reconstruct correlated hot data chunks into a new stripe. Since these data chunks have a strong correlation, they tend to be updated together within a short time span. This co-update within a stripe more efficiently utilizes the parity cache to convert partial-stripe updates into a full-stripe update. We have implemented Cap on a RAID-5 SSD array in Linux Kernel 4.3. Experimental results show that Cap improves the I/O bandwidth by 54%~145% compared with the Linux software RAID. Compared with the state-of-the-art parity caching scheme PPC, Cap improves the I/O bandwidth by 14%~31%.</p>
<p>RAID;data chunk&#xFF1B;</p>
<h2 id="2b-side-channels"><a name="2b-side-channels" class="anchor-navigation-ex-anchor" href="#2b-side-channels"><i class="fa fa-link" aria-hidden="true"></i></a><a name="2b-side-channels" class="plugin-anchor" href="#2b-side-channels"><i class="fa fa-link" aria-hidden="true"></i></a>2B: Side Channels</h2>
<h2 id="3a-security-and-capability"><a name="3a-security-and-capability" class="anchor-navigation-ex-anchor" href="#3a-security-and-capability"><i class="fa fa-link" aria-hidden="true"></i></a><a name="3a-security-and-capability" class="plugin-anchor" href="#3a-security-and-capability"><i class="fa fa-link" aria-hidden="true"></i></a>3A: Security and Capability</h2>
<p><strong>CheriRTOS: A Capability Model for Embedded Devices</strong></p>
<blockquote>
<p>&#x200B;    Hongyan Xia, Jonathan Woodruff, Hadrien Barral, Lawrence Esswood, Alexandre Joannou, Robert Kovacsics, David Chisnall, Michael Roe, Brooks Davis, Edward Napierala, John Baldwin, Khilan Gudka, Peter G. Neumann, Alexander Richardson, Simon W. Moore, Robert N. M. Watson:</p>
</blockquote>
<p><strong>Embedded systems</strong> are deployed ubiquitously among various sectors including automotive, medical, robotics and avionics. As these devices become increasingly connected, the <strong>attack</strong> surface also increases tremendously; new mechanisms must be deployed to defend against more sophisticated attacks while not violating resource constraints. In this paper we present <strong>CheriRTOS</strong> on <u>CHERI-64</u>, a hardware-software platform atop Capability Hardware Enhanced RISC Instructions (CHERI) for embedded systems. Our system provides efficient and scalable task isolation, fast and secure inter-task communication, fine-grained memory safety, and real-time guarantees, using hardware capabilities as the sole protection mechanism. We <strong>summarize</strong> <u>state-of-the-art security and memory safety</u> for embedded systems for comparison with our platform, illustrating the superior substrate provided by CHERI&apos;s capabilities. Finally, our evaluations show that a capability system can be implemented within the constraints of embedded systems.</p>
<p>&#x5D4C;&#x5165;&#x5F0F;&#x8BBE;&#x5907;</p>
<hr>
<p><strong>ReadPRO: Read Prioritization Scheduling in ORAM for Efficient Obfuscation in Main Memories</strong></p>
<blockquote>
<p>&#x200B;    Joydeep Rakshit, Kartik Mohanram:</p>
</blockquote>
<p>Modern memory systems are susceptible to <strong>data confidentiality attacks</strong> that leverage memory access pattern information to obtain secret data. Oblivious RAM (ORAM) is a secure cryptographic construct that effectively thwarts <strong>access-pattern-based attacks</strong>. However, in Path ORAM (state-of-the-art efficient ORAM for main memories) and its variants, each memory request (read or write) is transformed to an ORAM access, which is a sequence of read and write operations, increasing the latency of the memory requests and degrading system performance. In practice, the ORAM access for a read request is on the critical path of program execution, blocked by ORAM accesses for older write requests. Although modern memory controllers (MCs) realize read prioritization through write buffering, the ORAM access translation of each memory request to multiple memory read and write operations results in frequent MC write buffer overflow, decreasing its efficiency. ReadPRO (Read Prioritization) scheduling in ORAM addresses this challenge by promoting read requests over write requests in the ORAM controller prior to their ORAM access translation, while preserving all data dependencies. ReadPRO complements read promotion with staggered writes, wherein ORAM accesses for write requests can be paused securely to serve ORAM accesses for read requests. Full-system evaluations on composite SPEC CPU2006 workloads show that ReadPRO decreases the average ORAM read latency by 75%, improving system performance by 40%.</p>
<p><strong>&#x5185;&#x5B58;&#x653B;&#x51FB;</strong></p>
<hr>
<p><strong>SGXlinger: A New Side-Channel Attack Vector Based on Interrupt Latency Against Enclave Execution.</strong> </p>
<blockquote>
<p>&#x200B;    Wenjian He, Wei Zhang, Sanjeev Das, Yang Liu</p>
</blockquote>
<p><strong>Software Guard Extension</strong> (<strong>SGX</strong>) is a new security feature that has been released in recent Intel commodity processors. It is designed to provide a user program with a strongly shielded environment against other components in the system, including the OS, firmware and hardware peripherals. With SGX, developers can securely deploy critical applications on untrusted remote platforms without the concern of information leakage. However, researchers have found several attacks against SGX, suggesting blind reliance on SGX is inadvisable, and promoting the need for a comprehensive study on the security property of SGX. In this paper, we discover a new attack vector SGXlinger to disclose information inside the protected program. Our attack monitors the interrupt latency of the SGX-protected program, and it is the first time that the interrupt latency is leveraged as a side-channel. We develop a framework to repeatedly measure the interrupt latency of an enclave program, and the evaluation shows we can learn coarse-grained information inside the shielded environment. In an experimental setting, we measure that the information leakage rate of the proposed side-channel can reach up to 35 Kbps.</p>
<hr>
<p><strong>Breaking the Oblivious-RAM Bandwidth Wall.</strong></p>
<blockquote>
<p>Hamza Omar, Syed Kamran Haider, Ling Ren, Marten van Dijk, Omer Khan</p>
</blockquote>
<p><strong>PathORAM</strong> is a popular security primitive for obfuscating memory access patterns from a secure processor to an insecure main memory. Emerging throughput multicore and GPU processors provide immense memory bandwidth via multiple on-chip memory controllers. PathORAM translates a single off-chip cache line access into ~100 cache lines, thereby stressing the available memory bandwidth. However, current PathORAM scheme shows degradation of bandwidth utilization with an increase in the number of memory controllers. This deprivation in bandwidth utilization is primarily due to the fact that PathORAM falls short in proportionate distribution of memory accesses among all available on-chip memory controllers. This paper presents a novel ORAM path distribution scheme that ensures balanced load distribution among parallel on-chip memory controllers, and consequently improves secure processor performance by ~24% over state-of-the-art PathORAM scheme.</p>
<h2 id="3b-microarchitecture"><a name="3b-microarchitecture" class="anchor-navigation-ex-anchor" href="#3b-microarchitecture"><i class="fa fa-link" aria-hidden="true"></i></a><a name="3b-microarchitecture" class="plugin-anchor" href="#3b-microarchitecture"><i class="fa fa-link" aria-hidden="true"></i></a>3B: Microarchitecture</h2>
<h2 id="4a-logic-and-circuit-design-1"><a name="4a-logic-and-circuit-design-1" class="anchor-navigation-ex-anchor" href="#4a-logic-and-circuit-design-1"><i class="fa fa-link" aria-hidden="true"></i></a><a name="4a-logic-and-circuit-design-1" class="plugin-anchor" href="#4a-logic-and-circuit-design-1"><i class="fa fa-link" aria-hidden="true"></i></a>4A: Logic and Circuit Design 1</h2>
<h2 id="4b-design-automation"><a name="4b-design-automation" class="anchor-navigation-ex-anchor" href="#4b-design-automation"><i class="fa fa-link" aria-hidden="true"></i></a><a name="4b-design-automation" class="plugin-anchor" href="#4b-design-automation"><i class="fa fa-link" aria-hidden="true"></i></a>4B: Design Automation</h2>
<h2 id="5a-novel-architectures"><a name="5a-novel-architectures" class="anchor-navigation-ex-anchor" href="#5a-novel-architectures"><i class="fa fa-link" aria-hidden="true"></i></a><a name="5a-novel-architectures" class="plugin-anchor" href="#5a-novel-architectures"><i class="fa fa-link" aria-hidden="true"></i></a>5A: Novel Architectures</h2>
<h2 id="5b-memory-1"><a name="5b-memory-1" class="anchor-navigation-ex-anchor" href="#5b-memory-1"><i class="fa fa-link" aria-hidden="true"></i></a><a name="5b-memory-1" class="plugin-anchor" href="#5b-memory-1"><i class="fa fa-link" aria-hidden="true"></i></a>5B: Memory 1</h2>
<p><strong>CART: Cache Access Reordering Tree for Efficient Cache and Memory Accesses in GPUs.</strong></p>
<blockquote>
<p>&#x200B;    Yongbin Gu, Lizhong Chen</p>
</blockquote>
<p><strong>Graphics processing units (GPUs)</strong> have been increasingly used to accelerate general purpose computing. Thousands of concurrently running threads in a GPU demand a highly efficient memory subsystem for data supply. <em><u>A key factor that affects the memory subsystem is the order of memory accesses</u></em>. While reordering memory accesses at L2 cache has large potential benefits to both cache and DRAM, little work has been conducted to exploit this. In this paper, we investigate the largely unexplored opportunity of L2 cache access reordering. We propose <strong>Cache Access Reordering Tree</strong> (<strong>CART</strong>), a novel architecture that can improve memory subsystem efficiency by actively reordering memory accesses at L2 cache to be cache-friendly and DRAM-friendly. Evaluation results using a wide range of benchmarks show that, the proposed CART is able to improve the average IPC of memory intensive benchmarks by 34.2% with only 1.7% area overhead.</p>
<p>&#x5728;cache&#x4E2D;&#x8FDB;&#x884C;&#x8BBF;&#x95EE;&#x6A21;&#x5F0F;&#x7684;&#x4FEE;&#x6539;</p>
<hr>
<p><strong>ArchSampler: Architecture-Aware Memory Sampling Library for In-Memory Applications.</strong></p>
<blockquote>
<p>Jian Zhou, Jun Wang:</p>
</blockquote>
<p>With the explosive rate of data growth, the limited scalability of the DRAM technology defies the performance potentials for <strong>in-memory applications</strong>. Fortunately, emerging non-volatile memory (NVM) technologies, such as Phase-Change Memory (PCM) and Memristor, are promising candidates for replacing DRAM. Emerging NVMs are very dense, hence promise large capacities. Additionally, NVMs are non-volatile, thus enable persistent applications and byte-addressable files. Both density and persistency are key enablers for in-memory applications. On the other side, emerging NVMs are slower than DRAM, thus optimizing for locality and avoiding contentions are key aspects to unlock the NVM performance. In this paper, we study the impact of memory contentions and architecture-oblivious implementations on the performance of sampling based in-memory approximation. <strong>Sampling</strong> <u>has become an imperative technique used to accelerate big data processing</u>, especially in today&apos;s emerging in-memory computing. However, we observe multiple times slow-down for nave and default implementations of in-memory data sampling. Accordingly, we propose <strong>ArchSampler</strong>, an architecture-aware sampling library. The main idea is to exploits the free choice of data samples to dynamically select which bank as a host to serve memory requests. Hence, ArchSampler enables efficient and high performing sampling through employing its knowledge of the NVM architectural details to maximize data locality and avoiding interthread contentions. Our evaluation shows that ArchSampler can achieve up to 1.62 speed up (1.20 on average) for different in-memory applications.</p>
<p><strong>In-memory</strong></p>
<hr>
<p><strong>PIM-TGAN: A Processing-in-Memory Accelerator for Ternary Generative Adversarial Networks.</strong></p>
<blockquote>
<p>&#x200B;    Adnan Siraj Rakin, Shaahin Angizi, Zhezhi He, Deliang Fan</p>
</blockquote>
<p><strong>Generative Adversarial Network</strong> (<strong>GAN</strong>) has emerged as one of the most promising semi-supervised learning methods where two neural nets train themselves in a competitive environment. In this paper, as far as we know, we are the first to present a statistically trained Ternarized Generative Adversarial Network (TGAN) with fully ternarized weights (i.e. -1,0,+1) to massively reduce the need for computation and storage resources in the conventional GAN structures. In the proposed <strong>TGAN</strong>, the computationally expensive convolution operations (i.e. Multiplication and Accumulation) in both generator and discriminator&apos;s forward path are converted into hardware-friendly Addition/Subtraction operations. Accordingly, we propose a <strong>Processing-in-Memory accelerator for TGAN called (PIM-TGAN)</strong> based on Spin-Orbit Torque Magnetic Random Access Memory (SOT-MRAM) computational sub-arrays to efficiently accelerate the training process of GAN within non-volatile memory. In addition, we propose a <strong>parallelism</strong> technique to further enhance the training efficiency of TGAN. Our device-to-architecture co-simulation results show that, with almost the same inception score to the baseline GAN with floating point number weights on different data-sets, the proposed PIM-TGAN can obtain ~25.6&#xD7; better energy-efficiency and 22&#xD7; speedup compared to GPU platform averagely, and, 9.2&#xD7; better energy-efficiency and 5.4&#xD7; speedup over the best processing-in-ReRAM accelerators.</p>
<p><strong>PIM&#x52A0;&#x901F;GAN&#x7F51;&#x7EDC;</strong></p>
<hr>
<p><strong>Path Prefetching: Accelerating Index Searches for In-Memory Databases.</strong></p>
<blockquote>
<p>&#x200B;    Shuo Li, Zhiguang Chen, Nong Xiao, Guangyu Sun</p>
</blockquote>
<p><strong>In-memory databases</strong> (<strong>IMDBs</strong>) store all working data in main memory, which makes memory accesses become the dominant factor of the whole system performance. Micro-architectural studies of mainstream in-memory on-line transaction processing (OLTP) systems show that more than half of the execution time goes to memory stalls. Moreover, for IMDBs that adopt aggressive transaction compilation optimizations, data misses from the last-level cache (LLC) are responsible for the majority of the overall stall time. In this paper, through profiling analysis of IMDBs we observe that <strong>index access misses</strong> dominate LLC data misses. Based on the key observation that adjacent keys tend to follow similar traversal paths in ordered index searches, we propose the <strong>path prefetching</strong> to mitigate LLC misses induced by ordered index searches, which records mappings between keys and their traversal paths and then generate prefetches for future same/adjacent keys. Experimental results show that for ordered index searches the proposed path prefetcher provides an average speedup of 27.4% over the baseline with no prefetching.</p>
<hr>
<p><strong>Reducing Inter-Application Interferences in Integrated CPU-GPU Heterogeneous Architecture.</strong></p>
<blockquote>
<p>&#x200B;    Hao Wen, Wei Zhang</p>
</blockquote>
<p>Current heterogeneous CPU-GPU architectures integrate general purpose CPUs and highly thread-level parallelized GPUs (Graphic Processing Units) in the same die. The contention in shared resources between CPU and GPU, such as the last level cache (LLC), interconnection network and DRAM, may degrade both CPU and GPU performance. Our experimental results show that GPU applications tend to have much more power than CPU applications to compete for the shared resources in LLC and on-chip network, and therefore make CPU suffer from more performance loss. To reduce the GPU&apos;s negative impact on CPU performance, we propose a simple yet effective method based on probability to control the LLC replacement policy for reducing the CPU&apos;s inter-core conflict misses caused by GPU without significantly impacting GPU performance. In addition, we develop two strategies to combine the probability based method for the LLC and an existing technique called virtual channel partition (VCP) for the interconnection network to further improve the CPU performance. The first strategy statically uses an empirically pre-determined probability value associated with VCP, which can improve the CPU performance by 26% on average, but degrades GPU performance by 5%. The second strategy uses a sampling method to monitor the network congestion and dynamically adjust the probability value used, which can improve the CPU performance by 24%, and only have 1 or 2% performance overhead on GPU applications.</p>
<h2 id="6a-memory-2"><a name="6a-memory-2" class="anchor-navigation-ex-anchor" href="#6a-memory-2"><i class="fa fa-link" aria-hidden="true"></i></a><a name="6a-memory-2" class="plugin-anchor" href="#6a-memory-2"><i class="fa fa-link" aria-hidden="true"></i></a>6A: Memory 2</h2>
<p><strong>Solar-DRAM: Reducing DRAM Access Latency by Exploiting the Variation in Local Bitlines.</strong></p>
<blockquote>
<p>&#x200B;    Jeremie Kim, Minesh Patel, Hasan Hassan, Onur Mutlu:</p>
</blockquote>
<p><strong>DRAM latency</strong> is a major bottleneck for many applications in modern computing systems. In this work, we rigorously characterize the effects of reducing DRAM access latency on 282 state-of-the-art LPDDR4 DRAM modules. As found in prior work on older DRAM generations (DDR3), we show that regions of LPDDR4 DRAM modules can be accessed with latencies that are significantly lower than manufacturer-specified values without causing failures. We present novel data that 1) further supports the viability of such latency reduction mechanisms and 2) exposes a variety of new cases in which access latencies can be effectively reduced. Using our observations, we propose a new <u>low-cost mechanism</u>, <strong>Solar-DRAM,</strong> that 1) identifies failure-prone regions of DRAM at reduced latency and 2) robustly reduces average DRAM access latency while maintaining data correctness, by issuing DRAM requests with reduced access latencies to non-failure-prone DRAM regions. We evaluate Solar-DRAM on a wide variety of multi-core workloads and show that for 4-core homogeneous workloads, Solar-DRAM provides an average (maximum) system performance improvement of 4.31% (10.87%) compared to using the default fixed DRAM access latency.</p>
<hr>
<p><strong>Scalable and Efficient Virtual Memory Sharing in Heterogeneous SoCs with TLB Prefetching and MMU-Aware DMA Engine.</strong> </p>
<blockquote>
<p>Andreas Kurth, Pirmin Vogel, Andrea Marongiu, Luca Benini:</p>
</blockquote>
<p><strong>Shared virtual memory (SVM)</strong> is key in heterogeneous systems on chip (<strong>SoCs</strong>), which combine a general-purpose host processor with a many-core accelerator, both for programmability and to avoid data duplication. However, SVM can bring a significant run time overhead when translation lookaside buffer (TLB) entries are missing. Moreover, allowing DMA burst transfers to write SVM traditionally requires buffers to absorb transfers that miss in the TLB. These buffers have to be overprovisioned for the maximum burst size, wasting precious on-chip memory, and stall all SVM accesses once they are full, hampering the scalability of parallel accelerators. In this work, we present our SVM solution that avoids the majority of TLB misses with prefetching, supports parallel burst DMA transfers without additional buffers, and can be scaled with the workload and number of parallel processors. Our solution is based on three novel concepts: To minimize the rate of TLB misses, the TLB is proactively filled by compiler-generated Prefetching Helper Threads, which use run-time information to issue timely prefetches. To reduce the latency of TLB misses, misses are handled by a variable number of parallel Miss Handling Helper Threads. To support parallel burst DMA transfers to SVM without additional buffers, we add lightweight hardware to a standard DMA engine to detect and react to TLB misses. Compared to the state of the art, our work improves accelerator performance for memory-intensive kernels by up to 4~ and by up to 60% for irregular and regular memory access patterns, respectively.</p>
<hr>
<p><strong>DR DRAM: Accelerating Memory-Read-Intensive Applications.</strong> </p>
<blockquote>
<p>&#x200B;    Yuhai Cao, Chao Li, Quan Chen, Jingwen Leng, Minyi Guo, Jing Wang, Weigong Zhang:</p>
</blockquote>
<p>Today, <strong>many data analytic workloads</strong> such as <strong>graph processing</strong> and <strong>neural network</strong> desire efficient memory <strong>read operation</strong>. The need for preprocessing various raw data also demands enhanced memory read bandwidth. Unfortunately, due to the necessity of dynamic refresh, modern DRAM system has to stall memory access during each refresh cycle. As DRAM device density continues to grow, the refresh time also needs to extend to cover more memory rows. Consequently, DRAM refresh operation can be a crucial throughput bottleneck for <strong>memory read intensive (MRI)</strong> data processing tasks. To fully unleash the performance of these applications, we revisit conventional DRAM architecture and refresh mechanism. We propose <strong>DR DRAM</strong>, an application-specific memory design approach that makes a novel tradeoff between read and write performance. Simply put, DR has two layers of meaning: device refresh and data recovery. It aims at eliminating stall by enabling read and refresh operations to be done simultaneously. Unlike traditional schemes, DR explores device refresh that only refreshes a specific device at a time. Meanwhile, DR increases read efficiency by recovering the inaccessible data that resides on a device under refreshing. Our design can be implemented on existing redundant data storage area on DRAM. In this paper we detail DR&apos;s architecture and protocol design. We evaluate it on a cycle accurate simulator. Our results show that DR can nearly eliminate refresh overhead for memory read operation and brings up to 12% extra maximum read bandwidth and 50~60% latency improvement on present DRR4 device.</p>
<hr>
<p><strong>Puzzle Memory: Multifractional Partitioned Heterogeneous Memory Scheme.</strong> </p>
<blockquote>
<p>&#x200B;    Jee Ho Ryoo, Shuang Song, Lizy K. John</p>
</blockquote>
<p>As current main memory technology scaling is coming close to an end due to its physical limitations, many emerging memory technologies are coming to the market to fill the scaling gap. Future memory systems will require a heterogeneous memory architecture where one technology acts as a low latency memory whereas the other acts as a high capacity memory. This will allow the future main memory system to continue to scale in terms of capacity, yet have similar or slightly better latency than today&apos;s DRAM technology. Prior work on data management in heterogeneous memory has optimized one or a maximum of two components in the computing stack. However, different components are good at different tasks in data management, so in the era of heterogeneous memory, it is inevitable that cooperative multi-component data management will be adopted in future systems. We propose a heterogeneous memory layout where two memories are laid out asymmetrically. The operating system is aware of this layout and places pages with different locality characteristics in different regions of memory. Finally, a custom hardware performs the data remapping to optimize the data placement at finer granularity than what is visible to the operating system. In the end, we show that our multi-component cooperative data management scheme can improve the overall system performance by up to 40%.</p>
<h2 id="6b-logic-and-circuit-design-2"><a name="6b-logic-and-circuit-design-2" class="anchor-navigation-ex-anchor" href="#6b-logic-and-circuit-design-2"><i class="fa fa-link" aria-hidden="true"></i></a><a name="6b-logic-and-circuit-design-2" class="plugin-anchor" href="#6b-logic-and-circuit-design-2"><i class="fa fa-link" aria-hidden="true"></i></a>6B: Logic and Circuit Design 2</h2>
<h2 id="7a-accelerators-and-gpus"><a name="7a-accelerators-and-gpus" class="anchor-navigation-ex-anchor" href="#7a-accelerators-and-gpus"><i class="fa fa-link" aria-hidden="true"></i></a><a name="7a-accelerators-and-gpus" class="plugin-anchor" href="#7a-accelerators-and-gpus"><i class="fa fa-link" aria-hidden="true"></i></a>7A: Accelerators and GPUs</h2>
<h2 id="7b-potpouri-1"><a name="7b-potpouri-1" class="anchor-navigation-ex-anchor" href="#7b-potpouri-1"><i class="fa fa-link" aria-hidden="true"></i></a><a name="7b-potpouri-1" class="plugin-anchor" href="#7b-potpouri-1"><i class="fa fa-link" aria-hidden="true"></i></a>7B: Potpouri 1</h2>
<h2 id="8a-nvm"><a name="8a-nvm" class="anchor-navigation-ex-anchor" href="#8a-nvm"><i class="fa fa-link" aria-hidden="true"></i></a><a name="8a-nvm" class="plugin-anchor" href="#8a-nvm"><i class="fa fa-link" aria-hidden="true"></i></a>8A: NVM</h2>
<p><strong>Breeze: User-Level Access to Non-Volatile Main Memories for Legacy Software</strong></p>
<blockquote>
<p>&#x200B;    Amirsaman Memaripour, Steven Swanson:</p>
</blockquote>
<p>Non-volatile main memory (<strong>NVMM</strong>) technologies, such as phase change memory and 3D XPoint, offer DRAM-like performance and byte-addressable access to persistent data. A wide range of applications (e.g., key-value stores and database systems) stand to benefit from the performance potential of these technologies. These potential benefits are greatest when applications can access memory directly via <strong>load/store</strong> instructions rather than conventional file-based interfaces. This approach presents several challenges. In particular, applications need guaranteed consistency and safety semantics to protect their data structures in the face of system failures and programming errors. Implementing data structures that meet these requirements is challenging and error-prone. Researchers have proposed several libraries and programming language extensions that simplify this task, but, to date, all the proposed solutions either require pervasive changes to existing software or rely on special hardware support. As a result, porting legacy applications to leverage NVMM is likely to be prohibitively difficult and time consuming. We propose <strong>Breeze</strong>, a NVMM toolchain that minimizes the changes necessary to enable legacy code to reap the benefits of directly accessing NVMM. Breeze guarantees data consistency and validity of persistent pointers regardless of failures. The toolchain transparently detects and logs writes to NVMM and provides a simple mechanism for identifying atomic sections while avoiding complications common in previous systems such as special persistent pointer types. Porting Memcached and MongoDB to use Breeze only requires changes to 5% of the source code compared to 7-14% for NVML and NVM-Direct. Breeze also provides equal or superior performance compared to NVML and NVM-Direct, outperforming them by up to 10x.</p>
<hr>
<p><strong>R-Cache: A Highly Set-Associative In-Package Cache Using Memristive Arrays.</strong> </p>
<blockquote>
<p>&#x200B;    Payman Behnam, Arjun Pal Chowdhury, Mahdi Nazm Bojnordi:</p>
</blockquote>
<p>Over the past decade, three-dimensional die stacking technology has been considered for building large-scale in-package memory systems. In particular, in-package DRAM cache has been considered as a promising solution for high band-width and large-scale cache architectures. There are, however, significant challenges such as limited energy efficiency, costly tag management, and physical limitations for scalability that need to be effectively addressed before one can adopt in-package caches in the real-world applications. This paper proposes <strong>R-Cache,</strong> an in-package cache made by 3D die stacking of memristive memory arrays to alleviate the above mentioned challenges. Our simulation results on a set of memory intensive parallel applications indicate that R-Cache outperforms the state-of-the-art proposals for in-package caches. R-Cache improves performance by 38% and 27% over the state-of-the-art direct mapped and set associative cache architectures, respectively. Moreover, R-Cache results in averages of 40% and 27% energy reductions as compared to the direct mapped and set-associative cache systems.</p>
<hr>
<p><strong>A Highly Non-Volatile Memory Scalable and Efficient File System.</strong></p>
<blockquote>
<p>&#x200B;    Fan Yang, Junbin Kang, Shuai Ma, Jinpeng Huai:</p>
</blockquote>
<p>With the rapid development of fast and byte-addressable non-volatile memories (NVMs), hybrid NVM/DRAM storage systems become promising for computer systems. Existing NVM file systems have already been optimized around the NVM properties. However, they inherit some design choices of block-oriented storage devices that lead to scalability bottlenecks and data copy overhead for ensuring data consistency. In this paper, we present <strong>noseFS</strong>, a highly non-volatile memory scalable and efficient File System. It is designed to achieve high performance through a bundle of novel techniques: (1) a scalable lightweight naming integrating VFS with the underlying file system namespace, (2) a fine-grained byte-unit file index tree avoiding redundant copy overhead introduced by Copy-On-Write, (3) a lightweight journaling providing atomicity and scalability on many-core platforms, and (4) a lightweight atomic-mmap providing strong consistency guarantee with low overhead by tracking dirty pages. Experimental results show that noseFS performs much better than the state-of-the-art file systems with equally strong data consistency guarantees, and achieves near-linear scalability on a 40-core machine.</p>
<hr>
<p><strong>NVCool: When Non-Volatile Caches Meet Cold Boot Attacks.</strong></p>
<blockquote>
<p>&#x200B;    Xiang Pan, Anys Bacha, Spencer Rudolph, Li Zhou, Yinqian Zhang, Radu Teodorescu:</p>
</blockquote>
<p>Non-volatile memories (NVMs) are expected to replace traditional DRAM and SRAM for both off-chip and on-chip storage. It is therefore crucial to understand their security vulnerabilities before they are deployed widely. This paper shows that NVM caches are vulnerable to so-called &quot;<strong>cold boot</strong>&quot; attacks, which involve physical access to the processor&apos;s cache. SRAM caches have generally been assumed invulnerable to cold boot attacks, because SRAM data is only persistent for a few milliseconds even at cold temperatures. Our study explores cold boot attacks on NVM caches and defenses against them. In particular, this paper demonstrates that hard disk encryption keys can be extracted from the NVM cache in multiple attack scenarios. We demonstrate a reproducible attack with very high probability of success. This paper also proposes an effective software-based countermeasure that can completely eliminate the vulnerability of NVM caches to cold boot attacks with a reasonable performance overhead.</p>
<h2 id="8b-test-and-verification"><a name="8b-test-and-verification" class="anchor-navigation-ex-anchor" href="#8b-test-and-verification"><i class="fa fa-link" aria-hidden="true"></i></a><a name="8b-test-and-verification" class="plugin-anchor" href="#8b-test-and-verification"><i class="fa fa-link" aria-hidden="true"></i></a>8B: Test and Verification</h2>
<h2 id="9a-network-on-chip-and-synchronization"><a name="9a-network-on-chip-and-synchronization" class="anchor-navigation-ex-anchor" href="#9a-network-on-chip-and-synchronization"><i class="fa fa-link" aria-hidden="true"></i></a><a name="9a-network-on-chip-and-synchronization" class="plugin-anchor" href="#9a-network-on-chip-and-synchronization"><i class="fa fa-link" aria-hidden="true"></i></a>9A: Network on Chip and Synchronization</h2>
<h2 id="9b-potpouri-2"><a name="9b-potpouri-2" class="anchor-navigation-ex-anchor" href="#9b-potpouri-2"><i class="fa fa-link" aria-hidden="true"></i></a><a name="9b-potpouri-2" class="plugin-anchor" href="#9b-potpouri-2"><i class="fa fa-link" aria-hidden="true"></i></a>9B: Potpouri 2</h2>
<h2 id="10a-file-system-and-cloud"><a name="10a-file-system-and-cloud" class="anchor-navigation-ex-anchor" href="#10a-file-system-and-cloud"><i class="fa fa-link" aria-hidden="true"></i></a><a name="10a-file-system-and-cloud" class="plugin-anchor" href="#10a-file-system-and-cloud"><i class="fa fa-link" aria-hidden="true"></i></a>10A: File System and Cloud</h2>
<h2 id="10b-fpga-and-machine-learning"><a name="10b-fpga-and-machine-learning" class="anchor-navigation-ex-anchor" href="#10b-fpga-and-machine-learning"><i class="fa fa-link" aria-hidden="true"></i></a><a name="10b-fpga-and-machine-learning" class="plugin-anchor" href="#10b-fpga-and-machine-learning"><i class="fa fa-link" aria-hidden="true"></i></a>10B: FPGA and Machine Learning</h2>
<footer class="page-footer"><span class="copyright">Copyright &#xA9; jabingu.com 2019 all right reserved&#xFF0C;powered by Gitbook</span><span class="footer-modification">File modification time&#xFF1A;
2019-08-20 14:55:41
</span></footer>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="1-ICCD-2019.html" class="navigation navigation-prev " aria-label="Previous page: ICCD 2019">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="3-ICCD-2017.html" class="navigation navigation-next " aria-label="Next page: ICCD 2017">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"ICCD 2018","level":"3.2","depth":1,"next":{"title":"ICCD 2017","level":"3.3","depth":1,"path":"conference/3-ICCD-2017.md","ref":"conference/3-ICCD-2017.md","articles":[]},"previous":{"title":"ICCD 2019","level":"3.1","depth":1,"path":"conference/1-ICCD-2019.md","ref":"conference/1-ICCD-2019.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-lunr","-search","search-pro","-sharing","sharing-plus","hide-element","splitter","anchors","katex","tbfed-pagefooter","github","custom-favicon","donate","expandable-chapters-small","back-to-top-button","anchor-navigation-ex","livereload"],"styles":{"website":"./styles/website.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright &copy jabingu.com 2019","modify_label":"File modification time：","modify_format":"YYYY-MM-DD HH:mm:ss"},"github":{"url":"https://github.com/jabingu"},"livereload":{},"splitter":{},"search-pro":{},"sharing-plus":{"qq":false,"all":["facebook","google","twitter","instapaper","linkedin","pocket","stumbleupon"],"douban":false,"facebook":true,"weibo":false,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":true,"google":false,"viber":false,"stumbleupon":false,"qzone":false,"linkedin":false},"donate":{"alipay":"./source/images/donate.png","alipayText":" ","button":"bingo","title":"","wechat":"","wechatText":"微信打赏"},"hide-element":{"elements":[".gitbook-link"]},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"anchor-navigation-ex":{"associatedWithSummary":true,"float":{"floatIcon":"fa fa-navicon","level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"mode":"float","multipleH1":true,"pageTop":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"printLog":false,"showGoTop":true,"showLevel":false},"favicon":"favicon.ico","back-to-top-button":{},"custom-favicon":{},"expandable-chapters-small":{},"sharing":{"douban":true,"facebook":true,"google":true,"qq":true,"all":["google","facebook","weibo","twitter","qq","qzone","linkedin","pocket"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchors":{}},"theme":"default","author":"jabingu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"jabingu's Book","language":"zh-hans","links":{"sidebar":{"Blog":"https://jabingu.com"}},"gitbook":"3.2.3","description":"write some conference paper"},"file":{"path":"conference/2-ICCD-2018.md","mtime":"2019-08-20T06:55:41.548Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-08-20T07:32:03.201Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing-plus/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-hide-element/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-donate/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

