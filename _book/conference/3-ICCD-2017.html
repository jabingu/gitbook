
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>ICCD 2017 · jabingu's Book</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="jabingu">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search-pro/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-donate/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="4-IPDPS-2017.html" />
    
    
    <link rel="prev" href="2-ICCD-2018.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    
    
        
        <li>
            <a href="https://jabingu.com" target="_blank" class="custom-link">Blog</a>
        </li>
    
    

    
    <li class="divider"></li>
    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">作品</li>
        
        
    
        <li class="chapter " data-level="2.1" >
            
                <span>
            
                    
                    [其他]
            
                </span>
            

            
        </li>
    

    
        
        <li class="header">conference</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="1-ICCD-2019.html">
            
                <a href="1-ICCD-2019.html">
            
                    
                    ICCD 2019
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="2-ICCD-2018.html">
            
                <a href="2-ICCD-2018.html">
            
                    
                    ICCD 2018
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="3.3" data-path="3-ICCD-2017.html">
            
                <a href="3-ICCD-2017.html">
            
                    
                    ICCD 2017
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.4" data-path="4-IPDPS-2017.html">
            
                <a href="4-IPDPS-2017.html">
            
                    
                    IPDPS 2017
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.5" data-path="5-EuroSys-2019.html">
            
                <a href="5-EuroSys-2019.html">
            
                    
                    EuroSys 2019
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            本书使用 GitBook 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >ICCD 2017</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon "></span><a href="#iccd-2017"><b></b>ICCD 2017</a></li><ul><li><span class="title-icon "></span><a href="#best-papers-session"><b></b>Best Papers Session</a></li><li><span class="title-icon "></span><a href="#s1a-hardware-security-i"><b></b>S1A: Hardware Security I</a></li><li><span class="title-icon "></span><a href="#s1b-read-write-optimizations-for-non-volatile-memory"><b></b>S1B: Read-Write Optimizations for Non-Volatile Memory</a></li><li><span class="title-icon "></span><a href="#s2a-stochastic-approximate-and-unary-computing"><b></b>S2A: Stochastic, Approximate, and Unary Computing</a></li><li><span class="title-icon "></span><a href="#s2b-energy-efficiency-through-heterogeneity"><b></b>S2B: Energy-Efficiency through Heterogeneity</a></li><li><span class="title-icon "></span><a href="#s3a-debugging-and-validation"><b></b>S3A: Debugging and Validation</a></li><li><span class="title-icon "></span><a href="#s3b-graph-processing-and-noc-architectures"><b></b>S3B: Graph Processing and NoC Architectures</a></li><li><span class="title-icon "></span><a href="#s4a-eda-with-focus-on-multicore-fpgas-and-3d"><b></b>S4A: EDA with Focus on Multicore, FPGAs, and 3D</a></li><ul><li><span class="title-icon "></span><a href="#s4b-hardware-acceleration-for-neural-networks"><b></b>S4B: Hardware Acceleration for Neural Networks</a></li></ul><li><span class="title-icon "></span><a href="#s5a-hardware-security-ii"><b></b>S5A: Hardware Security II</a></li><li><span class="title-icon "></span><a href="#s5b-memory-and-cache-optimizations"><b></b>S5B: Memory and Cache Optimizations</a></li><li><span class="title-icon "></span><a href="#s6a-verification-and-fault-tolerance"><b></b>S6A: Verification and Fault Tolerance</a></li><li><span class="title-icon "></span><a href="#s6b-lithography-and-patterning"><b></b>S6B: Lithography and Patterning</a></li><li><span class="title-icon "></span><a href="#ss1-on-how-to-design-and-manage-complex-heterogeneous-distributed-computing-systems"><b></b>SS1: On How to Design and Manage Complex Heterogeneous Distributed Computing Systems</a></li><li><span class="title-icon "></span><a href="#s7a-lcd-with-focus-on-emerging-technology"><b></b>S7A: LCD with Focus on Emerging Technology</a></li><li><span class="title-icon "></span><a href="#s7b-power-performance-optimization-of-multicore-architecture"><b></b>S7B: Power-Performance Optimization of Multicore Architecture</a></li><li><span class="title-icon "></span><a href="#s8a-synthesis-and-security"><b></b>S8A: Synthesis and Security</a></li><li><span class="title-icon "></span><a href="#s8b-cloud-and-storage-solutions"><b></b>S8B: Cloud and Storage Solutions</a></li><li><span class="title-icon "></span><a href="#ss2-effective-voltage-scaling-in-late-cmos-era"><b></b>SS2: Effective Voltage Scaling in Late CMOS Era</a></li><li><span class="title-icon "></span><a href="#ss3-spin-computing-lower-the-barrier-between-memory-and-logic"><b></b>SS3: Spin-Computing: Lower the Barrier between Memory and Logic</a></li><li><span class="title-icon "></span><a href="#s9a-architecture-and-microarchitecture-optimizations"><b></b>S9A: Architecture and Microarchitecture Optimizations</a></li><li><span class="title-icon "></span><a href="#s9b-novel-architecture-with-3d-and-flash-memory"><b></b>S9B: Novel Architecture with 3D and Flash Memory</a></li></ul></ul></div><a href="#iccd-2017" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><h1 id="iccd-2017"><a name="iccd-2017" class="anchor-navigation-ex-anchor" href="#iccd-2017"><i class="fa fa-link" aria-hidden="true"></i></a><a name="iccd-2017" class="plugin-anchor" href="#iccd-2017"><i class="fa fa-link" aria-hidden="true"></i></a>ICCD 2017</h1>
<blockquote>
<p>&#x6B7B;&#x4EA1;&#x662F;&#x6D3B;&#x8FC7;&#x7684;&#x751F;&#x547D;&#xFF0C;&#x751F;&#x6D3B;&#x662F;&#x5728;&#x8DEF;&#x4E0A;&#x7684;&#x6B7B;&#x4EA1;&#x3002;</p>
<p align="right">&#x2014;&#x2014;&#x535A;&#x5C14;&#x8D6B;&#x65AF;&#x3000;&#x3000;</p>



</blockquote>
<p><strong>&#x76EE;&#x5F55;&#xFF1A;</strong></p>
<blockquote>
<p>**Best Papers Session    </p>
<p>Session 1A: Hardware Security I          </p>
<p>Session 1B: Read-Write Optimizations for Non-Volatile Memory    </p>
<p>Session 2A: Stochastic, Approximate, and Unary Computing</p>
<p>Session 2B: Energy-Efficiency through Heterogeneity</p>
<p>Session 3A: Debugging and Validation</p>
<p>Session 3B: Graph Processing and NoC Architectures</p>
<p>Session 4A: EDA with Focus on Multicore, FPGAs, and 3D</p>
<p>Session 4B: Hardware Acceleration for Neural Networks</p>
<p>Session 5A: Hardware Security II</p>
<p>Session 5B: Memory and Cache Optimizations</p>
<p>Session 6A: Verification and Fault Tolerance</p>
<p>Session 6B: Lithography and Patterning</p>
<p>Special Session 1: On How to Design and Manage Complex Heterogeneous Distributed Computing Systems</p>
<p>Session 7A: LCD with Focus on Emerging Technology</p>
<p>Session 7B: Power-Performance Optimization of Multicore Architecture</p>
<p>Session 8A: Synthesis and Security</p>
<p>Session 8B: Cloud and Storage Solutions</p>
<p>Special Session 2: Effective Voltage Scaling in Late CMOS Era</p>
<p>Special Session 3: Spin-Computing: Lower the Barrier between Memory and Logic</p>
<p>Session 9A: Architecture and Microarchitecture Optimizations</p>
<p>Session 9B: Novel Architecture with 3D and Flash Memory</p>
</blockquote>
<h2 id="best-papers-session"><a name="best-papers-session" class="anchor-navigation-ex-anchor" href="#best-papers-session"><i class="fa fa-link" aria-hidden="true"></i></a><a name="best-papers-session" class="plugin-anchor" href="#best-papers-session"><i class="fa fa-link" aria-hidden="true"></i></a>Best Papers Session</h2>
<h2 id="s1a-hardware-security-i"><a name="s1a-hardware-security-i" class="anchor-navigation-ex-anchor" href="#s1a-hardware-security-i"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s1a-hardware-security-i" class="plugin-anchor" href="#s1a-hardware-security-i"><i class="fa fa-link" aria-hidden="true"></i></a>S1A: Hardware Security I</h2>
<h2 id="s1b-read-write-optimizations-for-non-volatile-memory"><a name="s1b-read-write-optimizations-for-non-volatile-memory" class="anchor-navigation-ex-anchor" href="#s1b-read-write-optimizations-for-non-volatile-memory"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s1b-read-write-optimizations-for-non-volatile-memory" class="plugin-anchor" href="#s1b-read-write-optimizations-for-non-volatile-memory"><i class="fa fa-link" aria-hidden="true"></i></a>S1B: Read-Write Optimizations for Non-Volatile Memory</h2>
<p><strong>Adaptive Prefetching for Accelerating Read and Write in NVM-Based File Systems</strong></p>
<blockquote>
<p>&#x200B;    Shengan Zheng, Hong Mei, Linpeng Huang, Yanyan Shen, Yanmin Zhu:</p>
</blockquote>
<p>The byte-addressable Non-Volatile Memory (<strong>NVM</strong>) offers fast, fine-grained access to persistent storage. While DRAM and NVM have similar read performance, the write operations of existing NVM materials incur longer latency and lower bandwidth than DRAM. This read-write asymmetry nature of NVM causes two bottlenecks for <strong>accessing read-and write-intensive file data</strong>: <u>expensive data block lookups via file inner structure</u> and <u>high-latency direct writes to data blocks in NVM</u>. However, existing NVM-based file systems fail to address both bottlenecks well. This paper presents <strong>WARP</strong>, an <strong>adaptive prefetching module</strong> designed for NVM-based file systems, which aims to deal with two bottlenecks effectively. WARP employs two acceleration approaches: 1) <u>mapping data blocks into kernel virtual address space to bypass the indirection of file inner structure for read-intensive file data</u>; and 2) <u>allocating DRAM buffer to absorb frequent writes for write-intensive file data</u>. We design a WARP benefit model to identify read-and write-intensive access patterns for file data, and use a successor prediction model to predict future data access based on historical file access traces. With WARP, we are able to prefetch file data according to both file access patterns and traces with consistency guarantee. WARP can be implemented on various NVM-based file systems, and we choose HMVFS for the experiments. The evaluation results show that HMVFS with WARP provides high prefetching accuracy and up to 32%-83% improvement compared with the state-of-the-art NVM-based <strong>file systems</strong>.</p>
<p><strong>NVM-based file system</strong>&#xFF1B;<strong>&#x9884;&#x53D6;</strong>&#xFF1B;<strong>buffer</strong></p>
<hr>
<p><strong>A Cost-Efficient NVM-Based Journaling Scheme for File Systems.</strong> </p>
<blockquote>
<p>&#x200B;    Xiaoyi Zhang, Dan Feng, Yu Hua, Jianxi Chen</p>
</blockquote>
<p>Modern file systems employ <strong>journaling</strong> techniques to guarantee <strong>data consistency</strong> in case of unexpected system crashes or power failures. However, journaling file systems usually suffer from performance decrease <u>due to the extra journal writes</u>. Moreover, the emerging non-volatile memory technologies (<strong>NVMs</strong>) have the potential capability to improve the performance of journaling file systems by being deployed as the journaling storage devices. However, traditional journaling techniques, which are designed for hard disks, fail to perform efficiently in NVMs. In order to address this problem, we propose an <strong>NVM-based journaling scheme</strong>, called <strong>NJS</strong>. The basic idea behind NJS is to <u>reduce the journaling overhead of traditional file systems while fully exploiting the byte-accessibility characteristic</u>, and <u>alleviating the relatively slow write and endurance limitation of NVM</u>. Our NJS consists of three major contributions: (i) <u>In order to minimize the amount of journal writes</u>, NJS only needs to write the metadata of file systems and over-write data to NVM as write-ahead logging, thus alleviating the relatively slow write and endurance limitation of NVM. (ii) We propose <u>a novel journaling update scheme</u> in which the journaling data blocks can be updated in the byte-granularity based on the difference of the old and new versions of journal blocks, thus fully exploiting the unique byte-accessibility characteristic of NVM. (iii) NJS includes <u>a garbage collection mechanism</u> that absorbs the redundant journal updates, and actively delays the checkpointing to the file system. Evaluation results show the efficiency and efficacy of NJS. For example, compared with original Ext4 with a ramdisk-based journaling device, the throughput improvement of Ext4 with our NJS is up to 137.1%.</p>
<p><strong>NVM-Based Journaling Scheme</strong>&#xFF1B;</p>
<hr>
<p><strong>TDV Cache: Organizing Off-Chip DRAM Cache of NVMM from a Fusion Perspective.</strong> </p>
<blockquote>
<p>&#x200B;    Tianyue Lu, Yuhang Liu, Haiyang Pan, Mingyu Chen</p>
</blockquote>
<p>Emerging Non-Volatile Memory (<strong>NVM</strong>) provides both larger memory capacity and higher energy efficiency, but has much longer access latency than traditional DRAM, thus DRAM can be used as an efficient cache to hide the long latency of Non-Volatile Main Memory (NVMM) system. <strong>Transparent Off-chip DRAM cache</strong> (<strong>TOD cache</strong>) is a new DRAM cache structure where off-chip DRAM module is used as <strong>L4 cache</strong> and managed by hardware. The capacity and latency ratio of TOD cache over NVM are both quite different from those of traditional on-chip SRAM or die-stacked DRAM cache over off-chip DRAM memory. All the factors including hit latency, miss latency and hit rate need to be re-considered for TOD cache design. In this study, we first point out that three types of traditional cache schemes cannot be used directly for TOD cache, since set-associative cache suffers from extra tag lookup latency, direct-mapped cache has low hit rate and tag cache is too small to efficiently hold the working sets of tags for DRAM cache. Based on these observations, we propose a novel cache scheme, <strong>TDV</strong>, that fuses these three different types of cache together to take their advantages. In TDV, a direct-mapped cache is used as the first-level cache to achieve short access latency, a set-associative victim cache is taken as the second-level cache to obtain extra high hit rate, and a SRAM tag cache only serves for the victim cache rather than the whole DRAM cache and thus improves the hit rate of tag cache significantly. The simulation results show that, TDV cache has a performance improvement of 6.3% and 8.3% on average than state-of-the-art direct-mapped (Alloy cache) and set-associative cache (ATCache) with same DRAM and SRAM capacity.</p>
<p>L4 cache</p>
<hr>
<p><strong>RCTP: Region Correlated Temporal Prefetcher</strong></p>
<blockquote>
<p>  Dennis Antony Varkey, Biswabandan Panda, Madhu Mutyam:</p>
</blockquote>
<p><strong>Hardware prefetcher</strong> is an essential component of modern processors that helps in boosting system performance by fetching the data before processor demands for the same. Hardware prefetching techniques have been proposed to exploit various kinds of access patterns. However, there are applications that are highly irregular in nature that evolved in the past decade, and have massive memory footprint. Temporal prefetching techniques are effective in predicting the future addresses of these irregular applications. Prior works on temporal prefetching use large data structures to store temporal patterns and future memory accesses are predicted using these patterns. <u>However, these techniques predict future accesses only when there is a pattern that is already trained for a given cache line address</u>. To address this issue, we propose <strong>Region Correlated Temporal Prefetcher</strong> (<strong>RCTP</strong>). Our technique correlates temporal patterns of memory regions and predicts future accesses for the region whose patterns are yet to be populated. Thus, RCTP helps in predicting cache line addresses whose first access is yet to happen unlike the traditional temporal prefetchers. We evaluate RCTP on SPEC CPU 2006, CRONO, and PBBS benchmark suites. RCTP outperforms the state-of-the-art temporal prefetcher named ISB by 26%, and a recent delta prefetcher called VLDP by 6%. This improvement comes with a hardware overhead of 1KB over ISB; however, RCTP does not require off-chip storage, unlike other temporal prefetchers.</p>
<p><strong>&#x786C;&#x4EF6;&#x9884;&#x53D6;</strong>&#xFF1B;&#x65F6;&#x95F4;&#x9884;&#x53D6;&#x5668;&#xFF1B;</p>
<hr>
<p><strong>A Shingle-Aware Persistent Cache Management Scheme for DM-SMR Disks.</strong></p>
<blockquote>
<p>&#x200B;    Tianming Yang, Haitao Wu, Ping Huang, Fei Zhang:</p>
</blockquote>
<p><strong>Shingled Magnetic Recording</strong> (<strong>SMR</strong>) Technology is a new promising <strong>disk</strong> technology, which enables high areal density for disk storage by adopting writing tracks in an overlapped manner. Due to track overlapping, however, SMR devices cannot support in-place updates on shingled disk tracks, as overwriting shingled tracks would damage previously written data on neighboring tracks, resulting in poor random write performance. <strong>Drive-managed SMR</strong> (<strong>DM-SMR</strong>) devices attempt to circumvent this idiosyncrasy by deploying an internal persistent cache which absorbs incoming writes temporally and persists them later on in batches, while providing backward compatibility by reserving the same block access interface. The persistent cache management policy has to maintain the mapping associations between fresh writes in the persistent cache and their target destinations on the disk, resulting in a so-called shingle translation layer (STL). Leveraging the sequential-only write property of shingled devices, in this paper, we propose <u>a new shingle aware persistent cache cleaning policy</u> for DM-SMR drives. Unlike traditional management polices, our new policy first merges cached updates by flushing writes that can be safely written to the disk, i.e., in the shingle direction, so that the cache space can be freed without paying the cost of read-modify-write. It then defaults to the normal cache merging process if it needs to reclaim more cache space. Our evaluations have shown that our persistent cache management policy delivers better performance (by up to 2.5X) via dramatically reducing write amplification associated with persistent cache cleaning and alleviating fragmented reads.</p>
<p><strong>&#x78C1;&#x76D8;SMR</strong></p>
<h2 id="s2a-stochastic-approximate-and-unary-computing"><a name="s2a-stochastic-approximate-and-unary-computing" class="anchor-navigation-ex-anchor" href="#s2a-stochastic-approximate-and-unary-computing"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s2a-stochastic-approximate-and-unary-computing" class="plugin-anchor" href="#s2a-stochastic-approximate-and-unary-computing"><i class="fa fa-link" aria-hidden="true"></i></a>S2A: Stochastic, Approximate, and Unary Computing</h2>
<h2 id="s2b-energy-efficiency-through-heterogeneity"><a name="s2b-energy-efficiency-through-heterogeneity" class="anchor-navigation-ex-anchor" href="#s2b-energy-efficiency-through-heterogeneity"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s2b-energy-efficiency-through-heterogeneity" class="plugin-anchor" href="#s2b-energy-efficiency-through-heterogeneity"><i class="fa fa-link" aria-hidden="true"></i></a>S2B: Energy-Efficiency through Heterogeneity</h2>
<h2 id="s3a-debugging-and-validation"><a name="s3a-debugging-and-validation" class="anchor-navigation-ex-anchor" href="#s3a-debugging-and-validation"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s3a-debugging-and-validation" class="plugin-anchor" href="#s3a-debugging-and-validation"><i class="fa fa-link" aria-hidden="true"></i></a>S3A: Debugging and Validation</h2>
<h2 id="s3b-graph-processing-and-noc-architectures"><a name="s3b-graph-processing-and-noc-architectures" class="anchor-navigation-ex-anchor" href="#s3b-graph-processing-and-noc-architectures"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s3b-graph-processing-and-noc-architectures" class="plugin-anchor" href="#s3b-graph-processing-and-noc-architectures"><i class="fa fa-link" aria-hidden="true"></i></a>S3B: Graph Processing and NoC Architectures</h2>
<h2 id="s4a-eda-with-focus-on-multicore-fpgas-and-3d"><a name="s4a-eda-with-focus-on-multicore-fpgas-and-3d" class="anchor-navigation-ex-anchor" href="#s4a-eda-with-focus-on-multicore-fpgas-and-3d"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s4a-eda-with-focus-on-multicore-fpgas-and-3d" class="plugin-anchor" href="#s4a-eda-with-focus-on-multicore-fpgas-and-3d"><i class="fa fa-link" aria-hidden="true"></i></a>S4A: EDA with Focus on Multicore, FPGAs, and 3D</h2>
<h3 id="s4b-hardware-acceleration-for-neural-networks"><a name="s4b-hardware-acceleration-for-neural-networks" class="anchor-navigation-ex-anchor" href="#s4b-hardware-acceleration-for-neural-networks"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s4b-hardware-acceleration-for-neural-networks" class="plugin-anchor" href="#s4b-hardware-acceleration-for-neural-networks"><i class="fa fa-link" aria-hidden="true"></i></a>S4B: Hardware Acceleration for Neural Networks</h3>
<h2 id="s5a-hardware-security-ii"><a name="s5a-hardware-security-ii" class="anchor-navigation-ex-anchor" href="#s5a-hardware-security-ii"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s5a-hardware-security-ii" class="plugin-anchor" href="#s5a-hardware-security-ii"><i class="fa fa-link" aria-hidden="true"></i></a>S5A: Hardware Security II</h2>
<h2 id="s5b-memory-and-cache-optimizations"><a name="s5b-memory-and-cache-optimizations" class="anchor-navigation-ex-anchor" href="#s5b-memory-and-cache-optimizations"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s5b-memory-and-cache-optimizations" class="plugin-anchor" href="#s5b-memory-and-cache-optimizations"><i class="fa fa-link" aria-hidden="true"></i></a>S5B: Memory and Cache Optimizations</h2>
<p><strong>DAAIP: Deadblock Aware Adaptive Insertion Policy for High Performance Caching.</strong></p>
<blockquote>
<p>&#x200B;    Newton, Sujit Kr Mahto, Suhit Pai, Virendra Singh:</p>
</blockquote>
<p>The commonly used <strong>LRU</strong> replacement policy for management of shared last-level cache (LLC) is not efficient as the policy is sharing-oblivious. LRU policy is suitable for applications which show a high-degree of data locality i.e. applications which are cache-friendly. However, applications with working data set greater than the available cache size or poor temporal locality perform poorly with LRU as most of the cache lines inserted by them simply traverse from MRU to LRU position without being re-referenced. Such applications are streaming in their cache behaviour and have very less data reuse. LRU policy makes inefficient use of <strong>shared caches</strong> for application mixes which are a combination of cache-friendly and streaming applications as the policy treats each cache line independently and doesn&apos;t learn from application&apos;s past cache reuse behaviour. We show that simple adaptive changes to the insertion policy can significantly improve system&apos;s performance. We propose <strong>Deadblock Aware Adaptive Insertion Policy</strong> (<strong>DAAIP</strong>) which dynamically adapts to the changing cache behaviour of applications sharing the LLC. DAAIP protects the data of application having high temporal locality from high access rate thrashing/streaming applications. Our proposed mechanism monitors each application at-runtime using cost-effective hardware circuits. The information collected is used to dynamically modify the insertion policy and implicitly partition the cache in favour of application showing more data locality. Our evaluation, with 39 multiprogrammed workloads, shows that DAAIP improves performance of dual-core system by up to 21% and on an average 5.8% over LLC caches managed by SRRIP replacement policy. We show that DAAIP also outperforms state-of-the-art cache replacement policy ABRip by 4.6% on system throughput metric.</p>
<p><strong>cache&#x66FF;&#x6362;&#x7B56;&#x7565;</strong></p>
<hr>
<p><strong>Dual Dictionary Compression for the Last Level Cache.</strong></p>
<blockquote>
<p>&#x200B;    Akshay Lahiry, David R. Kaeli:</p>
</blockquote>
<p>The performance of <strong>GPUs</strong> is rapidly improving as the top GPU vendors keep pushing the boundaries of process technologies. While larger die sizes help improve performance given the nature of parallel workloads, additional architectural improvements can also help by utilizing the available die real estate more efficiently. Introducing a compressed <strong>Last Level Cache</strong> (<strong>LLC</strong>) can make better use of die area, and can improve memory system performance. With widespread adoption of high-resolution displays, most modern game developers are trying to generate high quality graphics output leveraging state-of-the-art GPUs, all of which greatly increases amount of data that needs to be processed. These modern graphics workloads will need to rely on compression to help save memory bandwidth and improve the performance of the LLC. <strong>A compressed LLC</strong> can help by increasing the hit-rate due to logical cache expansion, as well as provide bandwidth savings due to compressed data on the memory bus. In this paper we propose a novel scheme to extend <u>dynamic dictionary-based compression</u> to store compressed data in memory. Current dictionary-based compression schemes need to decompress the data when a cache block gets evicted. This is because the dynamic dictionary entries are not guaranteed to stay the same and data consistency cannot be maintained. This results in bandwidth savings that is limited to the logical cache expansion. We propose a dual-dictionary scheme (DDC) that can help maintain data consistency, as well as improve bandwidth savings. Our scheme saves bandwidth by coupling logical cache expansion with compressed data on the memory bus. We achieve bandwidth savings of 18.55% for reads and 11.01% for writes, on average, for a diverse range of graphics workloads.</p>
<p><strong>compression</strong></p>
<hr>
<p><strong>Jenga: Efficient Fault Tolerance for Stacked DRAM</strong></p>
<blockquote>
<p>&#x200B;    Georgios Mappouras, Alireza Vahid, A. Robert Calderbank, Derek R. Hower, Daniel J. Sorin:</p>
</blockquote>
<p>In this paper, we introduce <strong>Jenga</strong>, a new scheme for protecting 3D DRAM, specifically high bandwidth memory (HBM), from failures in bits, rows, banks, channels, dies, and TSVs. By providing redundancy at the granularity of a cache block-rather than across blocks, as in the current state of the art-Jenga achieves greater error-free performance and lower error recovery latency. We show that Jenga&apos;s runtime is on average only 1.03x the runtime of our Baseline across a range of benchmarks. Additionally, for memory intensive benchmarks, Jenga is on average 1.11x faster than prior work.</p>
<hr>
<p><strong>SelSMaP: A Selective Stride Masking Prefetching Scheme.</strong></p>
<blockquote>
<p>Jiajun Wang, Reena Panda, Lizy Kurian John:</p>
</blockquote>
<p>Although <strong>prefetching</strong> concepts have been proposed for decades, new challenges are introduced by sophisticated system architecture and emerging applications. Large instruction windows coupled with out-of-order execution makes program data access sequence distorted from cache perspective. Big data applications stress memory subsystems heavily with their large working set sizes and complex data access patterns. To address such challenges, this work proposes <u>a high performance hardware prefetching scheme</u>, <strong>SelSMaP</strong>. SelSMaP is able to detect both <u>regular</u> and <u>non-uniform stride</u> patterns by <u>taking the minimum observed address offset</u> (called a <strong>reference stride</strong>) as a heuristic. We evaluated SelSMaP with CloudSuite workloads and SPEC CPU2006 benchmarks. SelSMaP achieves an average CloudSuite performance improvement of 30% over non-prefetching system. With one to two order of magnitude less storage and much less functional logic, SelSMaP outperforms the highest-performing prefetcher by 8.6% in CloudSuite workloads.</p>
<p><strong>&#x7247;&#x4E0A;&#x9884;&#x53D6;</strong></p>
<hr>
<p><strong>T2: A Highly Accurate and Energy Efficient Stride Prefetcher.</strong></p>
<blockquote>
<p>Sushant Kondguli, Michael Huang:</p>
</blockquote>
<p><strong>Prefetching</strong> is a central element in most microarchitectures. Many different algorithms have been proposed with varying degrees of complexity and effectiveness. There is a tradeoff among various aspects of <u>coverage</u>, <u>accuracy</u>, and <u>cost</u>, especially when we try to exploit both simpler access patterns and more complex ones simultaneously. In this paper, we propose a design that only targets <strong>canonical strided</strong> access patterns, but does so with a very high accuracy. Compared to many other state-of-the-art prefetchers, sometimes with much more ambitious coverage, our design incurs much less memory traffic, reduces energy consumption, while still performs better on average.</p>
<h2 id="s6a-verification-and-fault-tolerance"><a name="s6a-verification-and-fault-tolerance" class="anchor-navigation-ex-anchor" href="#s6a-verification-and-fault-tolerance"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s6a-verification-and-fault-tolerance" class="plugin-anchor" href="#s6a-verification-and-fault-tolerance"><i class="fa fa-link" aria-hidden="true"></i></a>S6A: Verification and Fault Tolerance</h2>
<h2 id="s6b-lithography-and-patterning"><a name="s6b-lithography-and-patterning" class="anchor-navigation-ex-anchor" href="#s6b-lithography-and-patterning"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s6b-lithography-and-patterning" class="plugin-anchor" href="#s6b-lithography-and-patterning"><i class="fa fa-link" aria-hidden="true"></i></a>S6B: Lithography and Patterning</h2>
<h2 id="ss1-on-how-to-design-and-manage-complex-heterogeneous-distributed-computing-systems"><a name="ss1-on-how-to-design-and-manage-complex-heterogeneous-distributed-computing-systems" class="anchor-navigation-ex-anchor" href="#ss1-on-how-to-design-and-manage-complex-heterogeneous-distributed-computing-systems"><i class="fa fa-link" aria-hidden="true"></i></a><a name="ss1-on-how-to-design-and-manage-complex-heterogeneous-distributed-computing-systems" class="plugin-anchor" href="#ss1-on-how-to-design-and-manage-complex-heterogeneous-distributed-computing-systems"><i class="fa fa-link" aria-hidden="true"></i></a>SS1: On How to Design and Manage Complex Heterogeneous Distributed Computing Systems</h2>
<h2 id="s7a-lcd-with-focus-on-emerging-technology"><a name="s7a-lcd-with-focus-on-emerging-technology" class="anchor-navigation-ex-anchor" href="#s7a-lcd-with-focus-on-emerging-technology"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s7a-lcd-with-focus-on-emerging-technology" class="plugin-anchor" href="#s7a-lcd-with-focus-on-emerging-technology"><i class="fa fa-link" aria-hidden="true"></i></a>S7A: LCD with Focus on Emerging Technology</h2>
<h2 id="s7b-power-performance-optimization-of-multicore-architecture"><a name="s7b-power-performance-optimization-of-multicore-architecture" class="anchor-navigation-ex-anchor" href="#s7b-power-performance-optimization-of-multicore-architecture"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s7b-power-performance-optimization-of-multicore-architecture" class="plugin-anchor" href="#s7b-power-performance-optimization-of-multicore-architecture"><i class="fa fa-link" aria-hidden="true"></i></a>S7B: Power-Performance Optimization of Multicore Architecture</h2>
<h2 id="s8a-synthesis-and-security"><a name="s8a-synthesis-and-security" class="anchor-navigation-ex-anchor" href="#s8a-synthesis-and-security"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s8a-synthesis-and-security" class="plugin-anchor" href="#s8a-synthesis-and-security"><i class="fa fa-link" aria-hidden="true"></i></a>S8A: Synthesis and Security</h2>
<h2 id="s8b-cloud-and-storage-solutions"><a name="s8b-cloud-and-storage-solutions" class="anchor-navigation-ex-anchor" href="#s8b-cloud-and-storage-solutions"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s8b-cloud-and-storage-solutions" class="plugin-anchor" href="#s8b-cloud-and-storage-solutions"><i class="fa fa-link" aria-hidden="true"></i></a>S8B: Cloud and Storage Solutions</h2>
<p><strong>A Scale-Out Enterprise Storage Architecture.</strong> </p>
<blockquote>
<p>Wonil Choi, Myoungsoo Jung, Mahmut T. Kandemir, Chita R. Das:</p>
</blockquote>
<p>A robust <strong>enterprise SSD</strong> design should provide scalable throughput and storage capacity by integrating (up to thousands) flash chips in a scale-out fashion. However, the current &quot;channel-based&quot; SSD architecture is not a scalable design choice to allow such a dense integration. Motivated by the inherent architectural scalability of PCIe, we propose <strong>UT-SSD</strong>, <u>a novel enterprise-scale scale-out SSD architecture</u>, which enables the connection of a large number of (1000s) flash chips using the native PCIe buses instead of the conventional channels. We also propose an architectural enhancement that further improves the performance of our base UT-SSD by maximizing flash utilization. Our experimental analysis of UT-SSD with workloads drawn from various domains shows that the throughput of UT-SSD can reach up to 110 GB/s by successfully aggregating the bandwidth of 4096 flash chips. In addition, our proposed enhancement over this base UT-SSD increases the flash utilization by 50.7%, which in turn results in 116% additional throughput improvement.</p>
<p><strong>enterprise SSD</strong></p>
<hr>
<p><strong>CloudShelter: Protecting Virtual Machines&apos; Memory Resource Availability in Clouds.</strong> </p>
<blockquote>
<p>&#x200B;    Tianwei Zhang, Yuan Xu, Yungang Bao, Ruby B. Lee:</p>
</blockquote>
<p>We present <strong>CloudShelter</strong>, an architecture to protect virtual machines&apos; memory availability from undesired resource contention on the <strong>cloud</strong> servers. We introduce a new micro-architectural metric: <strong>Memory Round Trip Time</strong>, to quantify VMs&apos; memory QoS. Using this metric, (1) CloudShelter defines new QoS options for customers when launching VMs. These options can guarantee VMs&apos; memory QoS at different levels even when they face intensive contention with co-located VMs; (2) CloudShelter periodically monitors VMs&apos; memory QoS at runtime: once QoS violations against customers&apos; demands are detected, CloudShelter places this VM into an isolated environment to eliminate contention. CloudShelter can reduce 30.1% performance interference from LLC/DRAM contention and 81.6% interference from bus contention1.</p>
<p>cloud</p>
<hr>
<p><strong>Using Disturbance Compensation and Data Clustering (DC)2 to Improve Reliability and Performance of 3D MLC Flash Memory.</strong></p>
<blockquote>
<p>Yazhi Feng, Dan Feng, Wei Tong, Yu Jiang, Chuanqi Liu</p>
</blockquote>
<p><strong>3D architectures</strong> are considered the most promising approach to continuously increasing memory density and reducing cost/bit for NAND flash memory by stacking more layers. However, 3D MLC flash memory brings two serious problems, referred to as cell-to-cell program disturbance and big block problem. To solve the disturbance problem for better reliability, we proposed a <u>Disturbance Compensation Programming Scheme</u> (<strong>DCPS</strong>). Based on quantitatively analyzing the disturbance from each direction in 3D flash memory, the scheme accordingly set the <strong>verify voltage</strong> (<strong>VVFY</strong>) a little lower than the original value when <strong>Incremental Step Pulse Programming</strong> (<strong>ISPP</strong>) is performed. After disturbance compensation, the threshold voltage of flash cells can shift towards the ideal distribution. Moreover, <strong>Read reference Voltage Shifting</strong> (<strong>RVS</strong>) and <strong>Artificial Compensation</strong> (<strong>AC</strong>) strategies on margin pages are introduced to adapt to the three-dimensional structures to further enhance reliability. To solve big block problem, <strong>Multiple-Level-Queue page</strong> allocation (<strong>MLQ</strong>) is proposed. We use multiple queues to filter the logical addresses of different update counts and choose different data blocks to respond. The stored data are gradually well organized and generate less data migration when performing garbage collection. Experimental results show that our design reduces the disturbed BER by at least 82% with respect to a FTL with traditional allocation and garbage collection scheme. Besides, we demonstrate MLQ can achieve more effective results than the state of the art scheme in the big block environment. The write amplification, I/O response time and the number of erasures are reduced by 31.2%, 22.2% and 14.6% on average, respectively.</p>
<p>Read reference Voltage Shifting&#xFF1B;&#x51CF;&#x5C11;BER</p>
<hr>
<p><strong>Improving Performance of TLC RRAM with Compression-Ratio-Aware Data Encoding.</strong></p>
<blockquote>
<p>&#x200B;    Jie Xu, Dan Feng, Wei Tong, Jingning Liu, Wen Zhou:</p>
</blockquote>
<p>Resistive Random Access Memory (<strong>RRAM</strong>) technology is proposed as a promising replacement candidate for DRAM-based main memory due to its good scalability, low standby power, and non-volatility. The structure of Triple-Level Cell (TLC) can offer higher data density over Single-Level Cell (SLC). However, TLC RRAM suffers from high write energy and latency. <strong>Data compression</strong> techniques can reduce the size of the data to store. In contrast, data encoding methods such as <strong>Incomplete Data Mapping</strong> (<strong>IDM</strong>) can &apos;expand&apos; the size for latency and energy reduction. We observe that the compression ratio of each cacheline varies, and therefore the saved space of each compressed cacheline is different. On the other hand, we find that different IDMs have different tradeoffs in capacity and write latency/energy. To fully exploit the space saved by compression for reducing the write latency/energy, and improving the performance of TLC RRAM-based main memory system, <strong>Compression-Ratio-Aware Data Encoding</strong> (<strong>CRADE</strong>) is proposed. The key idea of CRADE is to <strong>dynamically</strong> <u>select the best-performing IDM according to the compression ratio of each cacheline</u>. The cacheline is compressed first, and then the compressed cacheline is encoded by IDM. For each compressed cacheline, the IDM which uses the fewest states to encode is applied on the condition that the encoded data size will not exceed the cacheline size. Experimental results show that CRADE can reduce the write energy by 15%, decrease the write latency by 19%, reduce the read latency by 4%, and improve the IPC performance by 2% compared with the state-of-the-art scheme.</p>
<p><strong>NVM</strong>&#xFF1B;<strong>compression</strong></p>
<hr>
<p><strong>Encoding Separately: An Energy-Efficient Write Scheme for MLC STT-RAM.</strong> </p>
<blockquote>
<p>Jie Xu, Dan Feng, Wei Tong, Jingning Liu, Wen Zhou:</p>
</blockquote>
<p>Multi Level Cell (<strong>MLC</strong>) Spin Transfer Torque RAM (STT-RAM) provides higher density than Single Level Cell (SLC) STT-RAM by storing two digital bits in a single cell, and is proposed as a promising candidate for on-chip cache. However, MLC STT-RAM suffers from high write energy. We observe that general <strong>encoding</strong> methods, which map the frequent data patterns to the energy-efficient resistance states, cannot reduce the write energy of MLC STT-RAM. <u>To reduce the write energy of MLC STT-RAM</u>, we propose a novel encoding method, i.e., <strong>Encoding Separately</strong> (<strong>ES</strong>). The key idea of ES is to <u>encode the hard bits and soft bits of MLCs separately</u>. The hard bits are encoded for fewer hard-bit writes (hard transitions) and soft bits are encoded for fewer soft-bit writes (soft transitions). Specifically, existing encoding methods commonly used in SLC can be applied to MLC STT-RAM when encoding the two bits separately. We further apply two encoding methods for SLC to MLC STT-RAM through encoding separately, and experimental results show that the proposed scheme can reduce the writes to hard bits and soft bits by 28% and 16%, and achieve an energy reduction of 25%.</p>
<p>MLC;encode</p>
<hr>
<p><strong>Quick-and-Dirty: Improving Performance of MLC PCM by Using Temporary Short Writes.</strong></p>
<blockquote>
<p>&#x200B;    Mingzhe Zhang, Lunkai Zhang, Lei Jiang, Frederic T. Chong, Zhiyong Liu:</p>
</blockquote>
<p>Low write performance is a major obstacle to the commercialization of MLC <strong>PCM</strong>. One opportunity for improving the latency of MLC PCM writes is to <u>use fewer SET iterations in a single write</u>. Unfortunately, the data written by these short writes have significantly shorter retention time and thus need frequent refreshes. As a result, it is impractical to use these short-latency, short-retention writes globally. In this paper, we analyze the temporal behavior of write operations in typical applications and propose <strong>Quick-and-Dirty</strong> (<strong>QnD</strong>), a lightweight scheme to improve the performance of MLC PCM. QnD dynamically performs the short-latency, short-retention write when write operations are bursty, and then uses short-latency, short-retention writes to mitigate the short retention problem when memory system is relatively quiet. Our experimental results show that QnD improves performance by 30.9% on geometric mean while still providing acceptable memory lifetime (7.58 years on geometric mean). We also provide sensitivity studies of the aggressiveness, memory coverage and granularity of QnD technique.</p>
<p>PCM&#xFF1B;</p>
<h2 id="ss2-effective-voltage-scaling-in-late-cmos-era"><a name="ss2-effective-voltage-scaling-in-late-cmos-era" class="anchor-navigation-ex-anchor" href="#ss2-effective-voltage-scaling-in-late-cmos-era"><i class="fa fa-link" aria-hidden="true"></i></a><a name="ss2-effective-voltage-scaling-in-late-cmos-era" class="plugin-anchor" href="#ss2-effective-voltage-scaling-in-late-cmos-era"><i class="fa fa-link" aria-hidden="true"></i></a>SS2: Effective Voltage Scaling in Late CMOS Era</h2>
<h2 id="ss3-spin-computing-lower-the-barrier-between-memory-and-logic"><a name="ss3-spin-computing-lower-the-barrier-between-memory-and-logic" class="anchor-navigation-ex-anchor" href="#ss3-spin-computing-lower-the-barrier-between-memory-and-logic"><i class="fa fa-link" aria-hidden="true"></i></a><a name="ss3-spin-computing-lower-the-barrier-between-memory-and-logic" class="plugin-anchor" href="#ss3-spin-computing-lower-the-barrier-between-memory-and-logic"><i class="fa fa-link" aria-hidden="true"></i></a>SS3: Spin-Computing: Lower the Barrier between Memory and Logic</h2>
<h2 id="s9a-architecture-and-microarchitecture-optimizations"><a name="s9a-architecture-and-microarchitecture-optimizations" class="anchor-navigation-ex-anchor" href="#s9a-architecture-and-microarchitecture-optimizations"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s9a-architecture-and-microarchitecture-optimizations" class="plugin-anchor" href="#s9a-architecture-and-microarchitecture-optimizations"><i class="fa fa-link" aria-hidden="true"></i></a>S9A: Architecture and Microarchitecture Optimizations</h2>
<h2 id="s9b-novel-architecture-with-3d-and-flash-memory"><a name="s9b-novel-architecture-with-3d-and-flash-memory" class="anchor-navigation-ex-anchor" href="#s9b-novel-architecture-with-3d-and-flash-memory"><i class="fa fa-link" aria-hidden="true"></i></a><a name="s9b-novel-architecture-with-3d-and-flash-memory" class="plugin-anchor" href="#s9b-novel-architecture-with-3d-and-flash-memory"><i class="fa fa-link" aria-hidden="true"></i></a>S9B: Novel Architecture with 3D and Flash Memory</h2>
<p><strong>CooECC: A Cooperative Error Correction Scheme to Reduce LDPC Decoding Latency in NAND Flash.</strong></p>
<blockquote>
<p>&#x200B;    Meng Zhang, Fei Wu, Yajuan Du, Chengmo Yang, Changsheng Xie, Jiguang Wan:</p>
</blockquote>
<p>The storage capacity of NAND Flash has increased by scaling down to smaller cell size and using multi-level storage technology, but data reliability is degraded by severer retention errors. To <u>ensure data reliability</u>, error correction codes (ECC) are adopted, such as BCH and low-density parity check (LDPC) codes. However, BCH codes are insufficient when raw bit error rates (RBER) caused by retention errors are high. As a result, BCH codes are inevitably replaced with LDPC codes with stronger error correction capability. Traditional <strong>LDPC</strong> codes are used to independently correct bit errors in the LSB and MSB pages. Unfortunately, decoding latency in such two pages is significantly unbalanced, MSB pages take much higher latency due to higher RBER, leading to suboptimal flash read performance. This paper proposes <u>a cooperative error correction scheme</u>, called <strong>CooECC</strong>, to reduce LDPC decoding latency of the MSB page in NAND Flash. By exploiting data error characteristics introduced by retention errors, CooECC integrates the decoding result of the LSB page into the initial information of LDPC decoding for the MSB page, making it more accurate. This in turn enables decoding to converge at a higher rate. Simulation results show that for LDPC schemes with information lengths of 2KB and 4KB, the decoding latency can be reduced by up to 87% and 84%, respectively, when RBER is as high as 8.0 &#xD7; 10 -3 .</p>
<p><strong>LDPC</strong></p>
<hr>
<p><strong>Fast, Ring-Based Design of 3D Stacked DRAM.</strong></p>
<blockquote>
<p>&#x200B;    Andrew J. Douglass, Sunil P. Khatri:</p>
</blockquote>
<p>As computer memory increases in size and processors continue to get faster, the memory subsystem becomes an increasing bottleneck to system performance. To mitigate the relatively slow DRAM memory chip speeds, a new generation of <strong>3D stacked DRAM</strong> is being developed, with lower power consumption and higher bandwidth. This paper proposes the use of 3D ring-based data fabrics for fast data transfer between these chips. The ring-based data fabric uses a fast standing wave oscillator to clock its transactions. With a fast clocking scheme, and multiple channels sharing the same bus, more channels are utilized while significantly reducing the number of through-silicon vias (TSVs). Experimental results show that our ring-based data fabric can reduce read latencies by almost 4X compared to traditional stacked memory chips. Variations of our scheme can also reduce power consumption compared to traditional memory stacks. Our Memory Architecture using a <strong>Ring-based Scheme</strong> (<strong>MARS</strong>) can effectively trade off power, throughput, and latency to improve system performance for different application spaces. We show that our MARS variants can deliver better latency (up to ~4X), power (up to ~8X), and performance per watt (up to ~4X) over HBM, when averaged over 11 SPEC CPU 2006 benchmarks. Other MARS variants provide higher throughput with similar power consumption compared to Wide I/O memory.</p>
<p><strong>3D Stacked DRAM</strong></p>
<hr>
<p><strong>Memory-Bounded Randomness for Hardware-Constrained Encrypted Computation.</strong></p>
<blockquote>
<p>&#x200B;    Nektarios Georgios Tsoutsos, Oleg Mazonka, Michail Maniatakos:</p>
</blockquote>
<p>Encrypted computation enables processing sensitive data directly in the encrypted domain, which allows outsourcing to third parties without compromising privacy. Recent solutions that leverage <u>partial homomorphic encryption</u>, however, require excessive lookup tables or obfuscated software oracles to implement branching over encrypted control values. To address these limitations and make encrypted computations more practical on memory-constrained systems, we present a novel approach for limiting the amount of randomness in probabilistic ciphertexts, using number theory primitives and hash tables. This allows de-randomizing probabilistic ciphertexts and define a new encrypted abstract machine that is memory-friendly to the target system. Compared to obfuscated oracles in previous work, our method performs control flow decisions over ciphertexts twice as fast, while requiring selectively small lookup tables.</p>
<hr>
<p><strong>Exploiting Process Variation for Read Performance Improvement on LDPC Based Flash Memory Storage Systems.</strong></p>
<blockquote>
<p>&#x200B;    Qiao Li, Liang Shi, Yejia Di, Yajuan Du, Chun Jason Xue, Edwin Hsing-Mean Sha:</p>
</blockquote>
<p>With the development of bit density and technology scaling, the process variation (PV) has become much severe on NAND flash memory. As PV presents reliability among flash blocks, which causes read performance variation to read data on different blocks. This paper proposes to improve <u>read performance of LDPC</u> based flash memory by exploiting the reliability characteristics of PV. First, a <strong>block grouping</strong> approach is proposed to classify the flash blocks based on their reliability. Then, <strong>a read data placement scheme</strong> is proposed, which is designed to place read-hot data on flash blocks with high reliability and move read-cold data to blocks with low reliability. Experiment results show that, with negligible overhead, the proposed scheme is able to significantly improve the read performance.</p>
<hr>
<p><strong>A Design-for-Test Solution for Monolithic 3D Integrated Circuits.</strong> </p>
<blockquote>
<p>&#x200B;    Abhishek Koneru, Sukeshwar Kannan, Krishnendu Chakrabarty</p>
</blockquote>
<p>Monolithic three-dimensional (M3D) integration has the potential to achieve significantly higher device density compared to 3D integration based on through-silicon vias (TSVs). We propose a test solution for M3D ICs based on dedicated test layers that are inserted between functional layers. We evaluate the cost associated with the proposed design-for-test (DfT) solution and compare it with that for a potential DfT solution based on the IEEE Std. P1838. Our results show that the proposed solution is more cost-efficient than the P1838-based solution for a wide range of inter-layer via (ILV) density, ILV yield, and defect density.</p>
<footer class="page-footer"><span class="copyright">Copyright &#xA9; jabingu.com 2019 all right reserved&#xFF0C;powered by Gitbook</span><span class="footer-modification">File modification time&#xFF1A;
2019-08-20 14:55:48
</span></footer>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="2-ICCD-2018.html" class="navigation navigation-prev " aria-label="Previous page: ICCD 2018">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="4-IPDPS-2017.html" class="navigation navigation-next " aria-label="Next page: IPDPS 2017">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"ICCD 2017","level":"3.3","depth":1,"next":{"title":"IPDPS 2017","level":"3.4","depth":1,"path":"conference/4-IPDPS-2017.md","ref":"conference/4-IPDPS-2017.md","articles":[]},"previous":{"title":"ICCD 2018","level":"3.2","depth":1,"path":"conference/2-ICCD-2018.md","ref":"conference/2-ICCD-2018.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-lunr","-search","search-pro","-sharing","sharing-plus","hide-element","splitter","anchors","katex","tbfed-pagefooter","github","custom-favicon","donate","expandable-chapters-small","back-to-top-button","anchor-navigation-ex","livereload"],"styles":{"website":"./styles/website.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright &copy jabingu.com 2019","modify_label":"File modification time：","modify_format":"YYYY-MM-DD HH:mm:ss"},"github":{"url":"https://github.com/jabingu"},"livereload":{},"splitter":{},"search-pro":{},"sharing-plus":{"qq":false,"all":["facebook","google","twitter","instapaper","linkedin","pocket","stumbleupon"],"douban":false,"facebook":true,"weibo":false,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":true,"google":false,"viber":false,"stumbleupon":false,"qzone":false,"linkedin":false},"donate":{"alipay":"./source/images/donate.png","alipayText":" ","button":"bingo","title":"","wechat":"","wechatText":"微信打赏"},"hide-element":{"elements":[".gitbook-link"]},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"anchor-navigation-ex":{"associatedWithSummary":true,"float":{"floatIcon":"fa fa-navicon","level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"mode":"float","multipleH1":true,"pageTop":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"printLog":false,"showGoTop":true,"showLevel":false},"favicon":"favicon.ico","back-to-top-button":{},"custom-favicon":{},"expandable-chapters-small":{},"sharing":{"douban":true,"facebook":true,"google":true,"qq":true,"all":["google","facebook","weibo","twitter","qq","qzone","linkedin","pocket"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchors":{}},"theme":"default","author":"jabingu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"jabingu's Book","language":"zh-hans","links":{"sidebar":{"Blog":"https://jabingu.com"}},"gitbook":"3.2.3","description":"write some conference paper"},"file":{"path":"conference/3-ICCD-2017.md","mtime":"2019-08-20T06:55:48.751Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-08-20T07:32:03.201Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-pro/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing-plus/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-hide-element/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-donate/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

